Here are five multiple-choice questions on 2_Core Algorithms for Problem Solving under From Bubble Sort to Merge Sort:

**Question 1**
Which of the following is a characteristic of Bubble Sort?
a. It is a stable sorting algorithm.
b. It has a time complexity of O(n).
c. It uses a recursive approach.
d. It is an adaptive sorting technique.

**Correct answer: a. It is a stable sorting algorithm.**
**Subtopic: Bubble Sort**
**What in that subtopic exactly: Characteristics of Bubble Sort**
**Difficulty: e**

**Question 2**
What is the average time complexity of Insertion Sort?
a. O(n^2)
b. O(n log n)
c. O(n)
d. O(log n)

**Correct answer: a. O(n^2)**
**Subtopic: Insertion Sort**
**What in that subtopic exactly: Time complexity**
**Difficulty: m**

**Question 3**
In Merge Sort, what is the purpose of the 'merge' step?
a. To divide the array into smaller subarrays.
b. To sort the subarrays recursively.
c. To combine the sorted subarrays into a single sorted array.
d. To find the maximum element in the array.

**Correct answer: c. To combine the sorted subarrays into a single sorted array.**
**Subtopic: Merge Sort**
**What in that subtopic exactly: Merge step**
**Difficulty: m**

**Question 4**
Why is Merge Sort considered a divide-and-conquer algorithm?
a. Because it uses a recursive approach.
b. Because it divides the array into smaller subarrays and solves them recursively.
c. Because it uses a dynamic programming approach.
d. Because it has a time complexity of O(n log n).

**Correct answer: b. Because it divides the array into smaller subarrays and solves them recursively.**
**Subtopic: Merge Sort**
**What in that subtopic exactly: Divide-and-conquer concept**
**Difficulty: m**

**Question 5**
Suppose we have an array of n elements, and we want to sort it using Merge Sort. How many recursive calls will be made in the worst case?
a. n/2
b. n
c. log(n)
d. 2^n

**Correct answer: c. log(n)**
**Subtopic: Merge Sort**
**What in that subtopic exactly: Recursion in Merge Sort**
**Difficulty: h**
Here are five multiple-choice questions on Core Algorithms for Problem Solving under Linear and Binary Search Techniques:

**Question 1**
What is the time complexity of the Linear Search algorithm?
a. O(n log n)
b. O(n)
c. O(log n)
d. O(1)

**Correct answer: b. O(n)**
**Subtopic: Linear Search**
**What in that subtopic exactly: Time complexity of Linear Search**
**Difficulty: e**

**Question 2**
Which of the following is a characteristic of Binary Search?
a. It can be used on unsorted lists.
b. It has a time complexity of O(n).
c. It can be used on lists of any size.
d. It is a recursive algorithm.

**Correct answer: c. It can be used on lists of any size.**
**Subtopic: Binary Search**
**What in that subtopic exactly: Characteristics of Binary Search**
**Difficulty: m**

**Question 3**
What is the condition for Binary Search to work correctly?
a. The list must be sorted in ascending order.
b. The list must be sorted in descending order.
c. The list must have an even number of elements.
d. The list must have an odd number of elements.

**Correct answer: a. The list must be sorted in ascending order.**
**Subtopic: Binary Search**
**What in that subtopic exactly: Precondition for Binary Search**
**Difficulty: m**

**Question 4**
What is the formula to calculate the midpoint in Binary Search?
a. Midpoint = (low + high) / 2
b. Midpoint = (low - high) / 2
c. Midpoint = low + (high - low) / 2
d. Midpoint = high - (high - low) / 2

**Correct answer: a. Midpoint = (low + high) / 2**
**Subtopic: Binary Search**
**What in that subtopic exactly: Midpoint calculation in Binary Search**
**Difficulty: h**

**Question 5**
Suppose we have a list of 16 elements and we want to find an element using Binary Search. If the element is not found in the list, what will be the number of comparisons made by the algorithm?
a. 4
b. 5
c. 3
d. 2

**Correct answer: b. 5**
**Subtopic: Binary Search**
**What in that subtopic exactly: Analysis of Binary Search**
**Difficulty: h**
Here are 5 multiple choice questions on Greedy Algorithm:

**Question 1**
Which of the following is a key characteristic of a Greedy Algorithm?
a. It always finds the optimal solution.
b. It makes the locally optimal choice at each step.
c. It is used to solve NP-hard problems.
d. It has a time complexity of O(n^2).

**Correct answer: b. It makes the locally optimal choice at each step.**
**Subtopic: Characteristics of Greedy Algorithm**
**What in that subtopic exactly: Definition of Greedy Algorithm**
**Difficulty: e**

**Question 2**
What is the main difference between a Greedy Algorithm and a Dynamic Programming Algorithm?
a. Greedy algorithms are faster, while dynamic programming algorithms are more accurate.
b. Greedy algorithms make local choices, while dynamic programming algorithms make global choices.
c. Greedy algorithms are used for sorting, while dynamic programming algorithms are used for searching.
d. Greedy algorithms are used for solving LP problems, while dynamic programming algorithms are used for solving NP-hard problems.

**Correct answer: b. Greedy algorithms make local choices, while dynamic programming algorithms make global choices.**
**Subtopic: Comparison of Greedy and Dynamic Programming**
**What in that subtopic exactly: Key differences between Greedy and Dynamic Programming**
**Difficulty: m**

**Question 3**
Which of the following problems can be solved using the Greedy Algorithm?
a. 0/1 Knapsack Problem
b. Traveling Salesman Problem
c. Longest Common Subsequence Problem
d. All of the above

**Correct answer: a. 0/1 Knapsack Problem**
**Subtopic: Applications of Greedy Algorithm**
**What in that subtopic exactly: Examples of problems solvable by Greedy Algorithm**
**Difficulty: m**

**Question 4**
A Greedy Algorithm is said to have a greedy choice property if:
a. The optimal solution can be constructed by making locally optimal choices.
b. The algorithm always finds the optimal solution.
c. The algorithm has a time complexity of O(n).
d. The algorithm is used to solve dynamic programming problems.

**Correct answer: a. The optimal solution can be constructed by making locally optimal choices.**
**Subtopic: Conditions for Greedy Algorithm**
**What in that subtopic exactly: Greedy choice property**
**Difficulty: h**

**Question 5**
Prove that the activities selected by the Greedy Algorithm for the activity selection problem are optimal.
a. By using mathematical induction to show that the greedy choice is always optimal.
b. By using a proof by contradiction to show that the greedy choice is never optimal.
c. By showing that the greedy choice has a time complexity of O(n^2).
d. By using dynamic programming to find the optimal solution.

**Correct answer: a. By using mathematical induction to show that the greedy choice is always optimal.**
**Subtopic: Analysis of Greedy Algorithm**
**What in that subtopic exactly: Proof of optimality of Greedy Algorithm**
**Difficulty: h**
Here are five multiple-choice questions on Core Algorithms for Problem Solving under Dynamic Programming:

**Question 1**
What is the main goal of Dynamic Programming?
a. To reduce the time complexity of a problem
b. To increase the time complexity of a problem
c. To simplify the problem
d. To make the problem more complex

**Correct answer: a. To reduce the time complexity of a problem**
**Subtopic: Introduction to Dynamic Programming**
**What in that subtopic exactly: Purpose of Dynamic Programming**
**Difficulty: e**

**Question 2**
Which of the following problems is an example of Dynamic Programming?
a. Fibonacci Sequence
b. Binary Search
c. Merge Sort
d. Quick Sort

**Correct answer: a. Fibonacci Sequence**
**Subtopic: Examples of Dynamic Programming**
**What in that subtopic exactly: Problems that use Dynamic Programming**
**Difficulty: m**

**Question 3**
What is the term used to describe the technique of breaking down a problem into smaller sub-problems in Dynamic Programming?
a. Memoization
b. Tabulation
c. Overlapping Subproblems
d. Optimal Substructure

**Correct answer: d. Optimal Substructure**
**Subtopic: Dynamic Programming Techniques**
**What in that subtopic exactly: Problem Decomposition**
**Difficulty: m**

**Question 4**
Consider a Dynamic Programming problem with a recurrence relation T(n) = 2T(n/2) + O(n). What is the time complexity of this problem?
a. O(n log n)
b. O(n^2)
c. O(2^n)
d. O(n)

**Correct answer: a. O(n log n)**
**Subtopic: Dynamic Programming Analysis**
**What in that subtopic exactly: Time Complexity Analysis**
**Difficulty: h**

**Question 5**
Which of the following statements is true about the longest common subsequence problem?
a. It is a classic example of a Dynamic Programming problem.
b. It can be solved using a greedy approach.
c. It has a polynomial time complexity.
d. It is an NP-complete problem.

**Correct answer: a. It is a classic example of a Dynamic Programming problem.**
**Subtopic: Dynamic Programming Applications**
**What in that subtopic exactly: LCS Problem Characteristics**
**Difficulty: h**
Here are five multiple-choice questions on Core Algorithms for Problem Solving under Graph Algorithms, ranging from easy to hard:

**Question 1**
What is the purpose of topological sorting in a directed acyclic graph (DAG)?
a. To find the shortest path between two nodes.
b. To detect cycles in the graph.
c. To order nodes such that for every edge (u,v), node u comes before node v.
d. To find the minimum spanning tree.

**Correct answer: c. To order nodes such that for every edge (u,v), node u comes before node v.**
**Subtopic: Topological Sorting**
**What in that subtopic exactly: Definition of Topological Sorting**
**Difficulty: e**

**Question 2**
Which of the following graph traversal algorithms is guaranteed to visit every node in an undirected graph?
a. Depth-First Search (DFS)
b. Breadth-First Search (BFS)
c. Topological Sorting
d. Dijkstra's Algorithm

**Correct answer: a. Depth-First Search (DFS)**
**Subtopic: Graph Traversal**
**What in that subtopic exactly: Properties of DFS**
**Difficulty: m**

**Question 3**
What is the time complexity of Dijkstra's algorithm when implemented using a binary heap?
a. O(E + V log V)
b. O(E + V^2)
c. O(E + V)
d. O(E log V)

**Correct answer: a. O(E + V log V)**
**Subtopic: Dijkstra's Algorithm**
**What in that subtopic exactly: Time Complexity of Dijkstra's Algorithm**
**Difficulty: m**

**Question 4**
Which of the following statements is true about Bellman-Ford algorithm?
a. It can handle negative weight edges but not negative cycles.
b. It can handle negative cycles but not negative weight edges.
c. It can handle both negative weight edges and negative cycles.
d. It cannot handle either negative weight edges or negative cycles.

**Correct answer: a. It can handle negative weight edges but not negative cycles.**
**Subtopic: Bellman-Ford Algorithm**
**What in that subtopic exactly: Properties of Bellman-Ford Algorithm**
**Difficulty: h**

**Question 5**
What is the purpose of the "relax" operation in Bellman-Ford algorithm?
a. To update the distance to a node if a shorter path is found.
b. To detect negative weight cycles in the graph.
c. To mark all nodes as unvisited.
d. To initialize the distance to all nodes as infinity.

**Correct answer: a. To update the distance to a node if a shorter path is found.**
**Subtopic: Bellman-Ford Algorithm**
**What in that subtopic exactly: Relax Operation in Bellman-Ford Algorithm**
**Difficulty: h**
